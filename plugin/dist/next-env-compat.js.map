{"version":3,"sources":["../src/next-env-compat.ts"],"names":["initialEnv","fs","path"],"mappings":"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","file":"next-env-compat.js","sourcesContent":["/**\n * Drop-in replacement for @next/env that uses varlock instead of dotenv\n *\n * This must be the default export of the module, and it must stay compatible with @next/env\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { execSync, type spawnSync } from 'child_process';\n// import { VarlockRedactor, resetRedactionMap, type SerializedEnvGraph } from 'varlock';\n\nexport type Env = { [key: string]: string | undefined };\nexport type LoadedEnvFiles = Array<{\n  path: string\n  contents: string\n  env: Env\n}>;\n\n/** will store the original values of process.env */\nexport let initialEnv: Env | undefined;\n\nlet lastReloadAt: Date | undefined;\n\nlet combinedEnv: Env | undefined;\nlet parsedEnv: Env | undefined;\n// this is used by next just to display the list of .env files in a startup log\nlet loadedEnvFiles: LoadedEnvFiles = [];\n\nconst IS_WORKER = !!process.env.NEXT_PRIVATE_WORKER;\nfunction debug(...args: Array<any>) {\n  if (false && !process.env.DEBUG_VARLOCK_NEXT_INTEGRATION) return;\n  console.log(\n    IS_WORKER ? 'worker -- ' : 'server -- ',\n    ...args,\n  );\n}\ndebug('âœ¨ LOADED @next/env module!');\n\n\n// Next.js only watches .env, .env.local, .env.development, .env.development.local\n// but we want to trigger reloads when .env.schema changes\n// so we set up an extra watcher, and trigger no-op changes to one of those files\nlet extraWatcherEnabled = false;\nconst NEXT_WATCHED_ENV_FILES = ['.env', '.env.local', '.env.development', '.env.development.local'];\nfunction enableExtraFileWatchers(dir: string) {\n  if (extraWatcherEnabled || IS_WORKER) return;\n  extraWatcherEnabled = true;\n\n  const envSchemaPath = path.join(dir, '.env.schema');\n  // its faster to update an existing file, so we check if the user has any\n  // otherwise we can create and destroy\n  let envFilePathToUpdate: string | null = null;\n  for (const envFileName of NEXT_WATCHED_ENV_FILES) {\n    const filePath = path.join(dir, envFileName);\n    if (fs.existsSync(filePath)) {\n      envFilePathToUpdate = filePath;\n      break;\n    }\n  }\n  let destroyFile = false;\n  if (!envFilePathToUpdate) {\n    envFilePathToUpdate ||= path.join(dir, '.env');\n    destroyFile = true;\n  }\n\n  debug('set up extra file watchers', envFilePathToUpdate, destroyFile);\n\n  fs.watchFile(envSchemaPath, { interval: 500 }, (curr, prev) => {\n    if (destroyFile) {\n      fs.writeFileSync(envFilePathToUpdate, '# trigger reload', 'utf-8');\n      setTimeout(() => {\n        fs.unlinkSync(envFilePathToUpdate);\n      }, 500);\n    } else {\n      const currentContents = fs.readFileSync(envFilePathToUpdate, 'utf-8');\n      fs.writeFileSync(envFilePathToUpdate, currentContents, 'utf-8');\n    }\n  });\n}\n\n\n\n\nexport function updateInitialEnv(newEnv: Env) {\n  if (Object.keys(newEnv).length) {\n    debug('updateInitialEnv', newEnv);\n    Object.assign(initialEnv || {}, newEnv);\n  }\n}\n\ntype Log = {\n  info: (...args: Array<any>) => void\n  error: (...args: Array<any>) => void\n};\n\nfunction replaceProcessEnv(sourceEnv: Env) {\n  Object.keys(process.env).forEach((key) => {\n    // Allow mutating internal Next.js env variables after the server has initiated.\n    // This is necessary for dynamic things like the IPC server port.\n    if (!key.startsWith('__NEXT_PRIVATE')) {\n      if (sourceEnv[key] === undefined || sourceEnv[key] === '') {\n        delete process.env[key];\n      }\n    }\n  });\n\n  Object.entries(sourceEnv).forEach(([key, value]) => {\n    process.env[key] = value;\n  });\n}\n\n// in original module, but does not appear to be used\nexport function processEnv(\n  _loadedEnvFiles: LoadedEnvFiles,\n  _dir?: string,\n  _log: Log = console,\n  _forceReload = false,\n  _onReload?: (envFilePath: string) => void,\n) {\n  return [process.env];\n}\n\nexport function resetEnv() {\n  if (initialEnv) {\n    replaceProcessEnv(initialEnv);\n  }\n}\n\nlet varlockEnv;\n\nexport function loadEnvConfig(\n  dir: string,\n  dev?: boolean,\n  log: Log = console,\n  forceReload = false,\n  onReload?: (envFilePath: string) => void,\n): {\n    combinedEnv: Env\n    parsedEnv: Env | undefined\n    loadedEnvFiles: LoadedEnvFiles\n  } {\n  if (!initialEnv) {\n    initialEnv ||= { ...process.env };\n  }\n  debug('loadEnvConfig!', 'forceReload = ', forceReload);\n  // Reload, 'dir = ', dir, 'dev = ', dev, 'onReload = ', onReload);\n\n  resetEnv();\n\n  varlockEnv = {\n    SECRET_FOO: { value: 'secret-foo', isSensitive: true },\n    NEXT_PUBLIC_FOO: { value: 'next-public-foo', isSensitive: false },\n    PUBLIC_FOO: { value: 'public-foo', isSensitive: false },\n    OVERRIDE_FROM_ENV_SPECIFIC_FILE: { value: 'override-me', isSensitive: false },\n    SECRET_OVERRIDE_FROM_ENV_SPECIFIC_FILE: { value: 'sensitive-override-me', isSensitive: true },\n  }\n  process.env.__VARLOCK_ENV = JSON.stringify(varlockEnv);\n\n  parsedEnv = {};\n  let dotEnvStr = '';\n  for (const [key, value] of Object.entries(varlockEnv)) {\n    parsedEnv[key] = value.value;\n    dotEnvStr += `${key}=${JSON.stringify(value.value)}\\n`;\n\n    process.env[key] = value.value;\n  }\n  dotEnvStr += `__VARLOCK_ENV=${JSON.stringify(varlockEnv)}\\n`;\n\n\n  // if we are building on vercel, we'll output our resolved env to .env.local\n  // because vercel won't actually call this loader in produciton except during the build\n  console.log('process.env', process.env);\n\n  if (process.env.VERCEL || process.env.WORKERS_CI || true) {\n    // console.log('writing new .env.local file');\n    // fs.writeFileSync(path.join(dir, '.env.local'), dotEnvStr, 'utf-8');\n    fs.writeFileSync(path.join(dir, '.env.production.local'), dotEnvStr, 'utf-8');\n  }\n\n\n  combinedEnv = {\n    ...initialEnv,\n    ...parsedEnv,\n  };\n  loadedEnvFiles = [{\n    path: 'injected1',\n    contents: '',\n    env: {},\n  }];\n\n  return { combinedEnv, parsedEnv, loadedEnvFiles };\n}\n"]}