{"version":3,"sources":["../src/runtime.ts","../src/patch-server-response.ts","../src/patch-console.ts","../src/plugin.ts"],"names":["ServerResponse","zlib","fs","path"],"mappings":"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","file":"plugin.js","sourcesContent":["const UNMASK_STR = '👁';\n\nexport type RedactMode = 'show_first_2' | 'show_last_2' | 'show_first_last';\n\n/**\n * utility to mask/redact a string, for example transforming \"hello\" into \"he▒▒▒\"\n * this function just redacts _any_ string passed in\n *\n * To redact sensitive parts of a larger object/string, use redactSensitiveConfig\n * */\nexport function redactString(valStr: string | undefined, mode?: RedactMode, hideLength = true) {\n  if (!valStr) return valStr;\n\n  const hiddenLength = hideLength ? 5 : valStr.length - 2;\n  const hiddenStr = '▒'.repeat(hiddenLength);\n\n  if (mode === 'show_last_2') {\n    return `${hiddenStr}${valStr.substring(valStr.length - 2, valStr.length)}`;\n  } else if (mode === 'show_first_last') {\n    return `${valStr.substring(0, 1)}${hiddenStr}${valStr.substring(valStr.length - 1, valStr.length)}`;\n  } else { // 'show_first_2' - also default\n    return `${valStr.substring(0, 2)}${hiddenStr}`;\n  }\n}\n\n\n\n/** key value lookup of sensitive values to their redacted version */\nlet sensitiveSecretsMap: Record<string, { key: string, redacted: string }> = {};\n\ntype ReplaceFn = (match: string, pre: string, val: string, post: string) => string;\nlet redactorFindReplace: undefined | { find: RegExp, replace: ReplaceFn };\n\nexport function resetRedactionMap(graph: { config: Record<string, { isSensitive: boolean, value: string }> }) {\n  // reset map of { [sensitive] => redacted }\n  sensitiveSecretsMap = {};\n  for (const itemKey in graph.config) {\n    const item = graph.config[itemKey];\n    if (item.isSensitive && item.value && isString(item.value)) {\n      // TODO: we want to respect masking settings from the schema (once added)\n      const redacted = redactString(item.value);\n      if (redacted) sensitiveSecretsMap[item.value] = { key: itemKey, redacted };\n    }\n  }\n\n  // reset find/replace regex+fn used for redacting secrets in strings\n  const findRegex = new RegExp(\n    [\n      `(${UNMASK_STR} )?`,\n      '(',\n      Object.keys(sensitiveSecretsMap)\n        // Escape special characters\n        .map((s) => s.replace(/[()[\\]{}*+?^$|#.,/\\\\\\s-]/g, '\\\\$&'))\n        // Sort for maximal munch\n        .sort((a, b) => b.length - a.length)\n        .join('|'),\n      ')',\n      `( ${UNMASK_STR})?`,\n    ].join(''),\n    'g',\n  );\n\n  const replaceFn: ReplaceFn = (match, pre, val, post) => {\n    // the pre and post matches only will be populated if they were present\n    // and they are used to unmask the secret - so we do not want to replace in this case\n    if (pre && post) return match;\n    return sensitiveSecretsMap[val].redacted;\n  };\n  redactorFindReplace = { find: findRegex, replace: replaceFn };\n}\n\n\n// While the module itself acts as a singleton to hold the current map of redacted values\n// we expose only the below const to end users\n\n\n/**\n * Redacts senstive config values from any string/array/object/etc\n *\n * NOTE - must be used only after varlock has loaded config\n * */\nexport function redactSensitiveConfig(o: any): any {\n  if (!redactorFindReplace) return o;\n  if (!o) return o;\n\n  // TODO: handle more cases?\n  // we can probably redact safely from a few other datatypes - like set,map,etc?\n  // objects are a bit tougher\n  if (Array.isArray(o)) {\n    return o.map(redactSensitiveConfig);\n  }\n  // try to redact if it's a plain object - not necessarily great for perf...\n  if (o && typeof (o) === 'object' && Object.getPrototypeOf(o) === Object.prototype) {\n    try {\n      return JSON.parse(redactSensitiveConfig(JSON.stringify(o)));\n    } catch (err) {\n      return o;\n    }\n  }\n\n  const type = typeof o;\n  if (type === 'string' || (type === 'object' && Object.prototype.toString.call(o) === '[object String]')) {\n    return (o as string).replaceAll(redactorFindReplace.find, redactorFindReplace.replace);\n  }\n\n  return o;\n}\n\n/**\n * utility to unmask a secret/sensitive value when logging to the console\n * currently this only works on a single secret, not objects or aggregated strings\n * */\nexport function revealSensitiveConfig(secretStr: string) {\n  // if redaction not enabled, we just return the secret itself\n  if (!(globalThis as any)._varlockOrigWriteToConsoleFn) return secretStr;\n  // otherwise we add some wrapper characters which will be removed by the patched console behaviour\n  return `${UNMASK_STR} ${secretStr} ${UNMASK_STR}`;\n}\n\n\n\n// this does not cover all cases, but serves our needs so far for Next.js\nfunction isString(s: any) {\n  return Object.prototype.toString.call(s) === '[object String]';\n}\n\n// reusable leak scanning helper function, used by various integrations\nexport function scanForLeaks(\n  toScan: string | Response | ReadableStream,\n  // optional additional information about what is being scanned to be used in error messages\n  meta?: {\n    method?: string,\n    file?: string,\n  },\n) {\n  function scanStrForLeaks(strToScan: string) {\n    // console.log('[varlock leak scanner] ', strToScan.substr(0, 100));\n\n    // TODO: probably should use a single regex\n    for (const sensitiveValue in sensitiveSecretsMap) {\n      if (strToScan.includes(sensitiveValue)) {\n        const itemKey = sensitiveSecretsMap[sensitiveValue].key;\n\n        // error stack can gets awkwardly buried since we're so deep in the internals\n        // so we'll write a nicer error message to help the user debug\n        console.error([\n          '',\n          `🚨 ${'DETECTED LEAKED SENSITIVE CONFIG'} 🚨`,\n          `> Config item key: ${itemKey}`,\n          ...meta?.method ? [`> Scan method: ${meta.method}`] : [],\n          ...meta?.file ? [`> File: ${meta.file}`] : [],\n          '',\n        ].join('\\n'));\n\n        throw new Error(`🚨 DETECTED LEAKED SENSITIVE CONFIG - ${itemKey}`);\n      }\n    }\n  }\n\n  // scan a string\n  if (isString(toScan)) {\n    scanStrForLeaks(toScan as string);\n    return toScan;\n  } else if (toScan instanceof Buffer) {\n    scanStrForLeaks(toScan.toString());\n    return toScan;\n  // scan a ReadableStream by piping it through a scanner\n  } else if (toScan instanceof ReadableStream) {\n    if (toScan.locked) {\n      // console.log('> stream already locked');\n      return toScan;\n    } else {\n      // console.log('> stream will be scanned!');\n    }\n    const chunkDecoder = new TextDecoder();\n    return toScan.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          const chunkStr = chunkDecoder.decode(chunk);\n          scanStrForLeaks(chunkStr);\n          controller.enqueue(chunk);\n        },\n      }),\n    );\n  }\n  // other things may be passed in like Buffer... but we'll ignore for now\n  return toScan;\n}\n\n// -----------\n\n\n\n\n// --------------\n\nlet initializedEnv = false;\nconst envValues = {} as Record<string, any>;\nconsole.log('LOADED ENV RUNTIME - initialized?', initializedEnv);\n\n\nexport function initVarlockEnv() {\n  console.log('⚡️ INIT VARLOCK ENV!');\n  try {\n    const serializedEnvData: Record<string, { value: string, isSensitive: boolean }> = JSON.parse(process.env.__VARLOCK_ENV || '{}');\n    resetRedactionMap({ config: serializedEnvData });\n    for (const [key, value] of Object.entries(serializedEnvData)) {\n      envValues[key] = (value as any).value;\n    }\n  } catch (err) {\n    console.error('failed to load varlock env', err, process.env.__VARLOCK_ENV);\n  }\n  initializedEnv = true;\n}\n\nif (process.env.__VARLOCK_ENV && !initializedEnv) initVarlockEnv();\n\nconst EnvProxy = new Proxy({} as Record<string, any>, {\n  get(target, prop) {\n    if (typeof prop !== 'string') throw new Error('prop keys cannot be symbols');\n    return envValues[prop];\n  },\n});\n\nexport const ENV = EnvProxy;\n","/*\n  This patches the global ServerResponse object to scan for secret leaks - currently used for next.js and remix\n*/\n\nimport zlib from 'node:zlib';\nimport { ServerResponse } from 'node:http';\nimport { redactSensitiveConfig, scanForLeaks } from './runtime';\n\n// NOTE - previously was using a symbol but got weird because of multiple builds and contexts...\nconst patchedKey = '_patchedByVarlock';\nexport function patchServerResponseToPreventClientLeaks(opts?: {\n  ignoreUrlPatterns?: Array<RegExp>,\n  scrub?: boolean,\n}) {\n  console.log('⚡️ patching ServerResponse');\n  if (Object.getOwnPropertyDescriptor(ServerResponse.prototype, patchedKey)) {\n    console.log('> already patched');\n    return;\n  }\n  \n\n  Object.defineProperty(ServerResponse.prototype, patchedKey, { value: true });\n\n  const serverResponseWrite = ServerResponse.prototype.write;\n\n  // @ts-ignore\n  ServerResponse.prototype.write = function varlockPatchedServerResponseWrite(...args) {\n    console.log('⚡️ patched ServerResponse.write');\n    // TODO: do we want to filter out some requests here? maybe based on the file type?\n\n    const rawChunk = args[0];\n\n    // for now, we only scan rendered html... may need to change this though for server components?\n    // so we bail if it looks like this response does not contain html\n    const contentType = this.getHeader('content-type')?.toString() || '';\n    // console.log('patched ServerResponse.write', contentType);\n    let runScan = (\n      contentType.startsWith('text/')\n      || contentType.startsWith('application/json')\n      // || contentType.startsWith('application/javascript')\n    );\n\n    const reqUrl = (this as any).req.url;\n    // console.log('> scan ServerResponse.write', contentType, reqUrl);\n    if (runScan && reqUrl && opts?.ignoreUrlPatterns?.some((pattern) => pattern.test(reqUrl))) {\n      runScan = false;\n    }\n\n    // we want to run the scanner on text/html and text/x-component (server actions)\n    // TODO: anything else?\n    if (!runScan) {\n      // @ts-ignore\n      return serverResponseWrite.apply(this, args);\n    }\n\n    // have to deal with compressed data, which is awkward but possible\n    const compressionType = this.getHeader('Content-Encoding');\n    let chunkStr;\n    let chunkType: 'string' | 'encoded' | 'gzip' | null = null;\n    if (typeof rawChunk === 'string') {\n      chunkType = 'string';\n      chunkStr = rawChunk;\n    } else if (!compressionType) {\n      chunkType = 'encoded';\n      const decoder = new TextDecoder();\n      chunkStr = decoder.decode(rawChunk);\n    } else if (compressionType === 'gzip') {\n      chunkType = 'gzip';\n      // first chunk of data contains only compression headers\n      if (!(this as any)._zlibChunks) {\n        // (this as any)._zlibHeadersChunk = rawChunk;\n        (this as any)._zlibChunks = [rawChunk];\n      } else {\n        // TODO: figure out how we can unzip one chunk at a time instead of storing everything\n        (this as any)._zlibChunks?.push(rawChunk);\n        try {\n          const unzippedChunk = zlib.unzipSync(Buffer.concat((this as any)._zlibChunks || []), {\n            flush: zlib.constants.Z_SYNC_FLUSH,\n            finishFlush: zlib.constants.Z_SYNC_FLUSH,\n          });\n          const fullUnzippedData = unzippedChunk.toString('utf-8');\n          chunkStr = fullUnzippedData.substring((this as any)._lastChunkEndIndex || 0);\n          (this as any)._lastChunkEndIndex = fullUnzippedData.length;\n        } catch (err) {\n          // console.log('error unzipping chunk', err);\n        }\n      }\n    }\n    // TODO: we may want to support other compression schemes? but currently only used in nextjs which is using gzip\n    if (chunkStr) {\n      // console.log('scanning!', chunkStr.substring(0, 1000));\n\n      // eslint-disable-next-line no-useless-catch\n      try {\n        scanForLeaks(chunkStr, { method: 'patched ServerResponse.write', file: (this as any).req.url });\n      } catch (err) {\n        // console.log('found secret in chunk', chunkType, chunkStr);\n        // console.log(this)\n        if (opts?.scrub) {\n          chunkStr = redactSensitiveConfig(chunkStr);\n          if (chunkType === 'string') {\n            args[0] = chunkStr;\n          } else if (chunkType === 'encoded') {\n            const encoder = new TextEncoder();\n            args[0] = encoder.encode(chunkStr);\n          } else if (chunkType === 'gzip') {\n            // currently unable to scrub gzip chunks\n            // this works sometimes, but othertimes causes decoding error\n            // we'll need to pass through chunks from a new gzip stream, because we don't have access to the underlying one\n            // args[0] = zlib.gzipSync(chunkStr, {\n            //   flush: zlib.constants.Z_SYNC_FLUSH,\n            //   finishFlush: zlib.constants.Z_SYNC_FLUSH,\n            // });\n          } else {\n            throw new Error('unable to scrub - unknown chunk type ' + chunkType);\n          }\n        } else {\n          throw err;  \n        }\n      }\n    }\n\n    // @ts-ignore\n    return serverResponseWrite.apply(this, args);\n  };\n\n\n  // calling `res.json()` in the api routes on pages router calls `res.end` without called `res.write`\n  const serverResponseEnd = ServerResponse.prototype.end;\n  // @ts-ignore\n  ServerResponse.prototype.end = function patchedServerResponseEnd(...args) {\n    // console.log('⚡️ patched ServerResponse.end');\n    const endChunk = args[0];\n    // console.log('patched ServerResponse.end', endChunk);\n    // this just needs to work (so far) for nextjs sending json bodies, so does not need to handle all cases...\n    if (endChunk && typeof endChunk === 'string') {\n      // TODO: currently this throws the error and then things just hang... do we want to try to return an error type response instead?\n      scanForLeaks(endChunk, { method: 'patched ServerResponse.end' });\n    }\n    // @ts-ignore\n    return serverResponseEnd.apply(this, args);\n  };\n}\n\n// ---\n// patchServerResponseToPreventClientLeaks();\n","import { redactSensitiveConfig } from \"./runtime\";\n\n\n/**\n * patches global console methods to redact sensitive config\n *\n * NOTE - this may not be 100% foolproof depending on the platform\n * */\nexport function patchConsole() {\n  console.log('⚡️ PATCHING CONSOLE!');\n  /* eslint-disable no-console, prefer-rest-params */\n  // if (!redactorFindReplace) return;\n\n  // our method of patching involves replacing an internal node method which may not be called if console.log itself has also been patched\n  // for example AWS lambdas patches this to write the logs to a file which then is pushed to the rest of their system\n\n  // so first we'll just patch the internal method do deal with normal stdout/stderr logs -------------------------------------\n\n  // we need the internal symbol name to access the internal method\n  const kWriteToConsoleSymbol = Object.getOwnPropertySymbols(globalThis.console).find((s) => s.description === 'kWriteToConsole');\n\n  // @ts-ignore\n  (globalThis as any)._varlockOrigWriteToConsoleFn ||= globalThis.console[kWriteToConsoleSymbol];\n  // @ts-ignore\n  globalThis.console[kWriteToConsoleSymbol] = function () {\n    (globalThis as any)._varlockOrigWriteToConsoleFn.apply(this, [\n      arguments[0],\n      redactSensitiveConfig(arguments[1]),\n      arguments[2],\n    ]);\n  };\n\n  // and now we'll wrap console.log (and the other methods) if it looks like they have been patched already ------------------\n  // NOTE - this will not fully redact from everything since we can't safely reach deep into objects\n  // ideally we would only turn this when the above method does not work, but it's not trivial to detect when it that is the case\n  // so we'll turn it on all the time for now...\n  if (\n    // !console.log.toString().includes('[native code]') &&\n    !(console.log as any)._varlockPatchedFn\n  ) {\n    for (const logMethodName of ['trace', 'debug', 'info', 'log', 'info', 'warn', 'error']) {\n      // @ts-ignore\n      const originalLogMethod = globalThis.console[logMethodName];\n\n      const patchedFn = function () {\n        // @ts-ignore\n        originalLogMethod.apply(this, Array.from(arguments).map(redactSensitiveConfig));\n      };\n      patchedFn._varlockPatchedFn = true;\n\n      // @ts-ignore\n      globalThis.console[logMethodName] = patchedFn;\n    }\n  }\n}\n\n/**\n * restore's original global console methods to stop redacting secrets\n *\n * (only needed during local development when switching settings on/off in a process that does not reload)\n * */\nexport function unpatchConsole() {\n  // we'll only care about the normal case where console.log has NOT been patched by something else... (see above)\n  if (!(globalThis as any)._varlockOrigWriteToConsoleFn) return;\n\n  const kWriteToConsoleSymbol = Object.getOwnPropertySymbols(globalThis.console).find((s) => s.description === 'kWriteToConsole');\n  // @ts-ignore\n  globalThis.console[kWriteToConsoleSymbol] = (globalThis as any)._varlockOrigWriteToConsoleFn;\n  delete (globalThis as any)._varlockOrigWriteToConsoleFn;\n}\n\n// ---\n\n// patchConsole();","/* eslint-disable prefer-rest-params */\nimport fs from 'node:fs';\nimport { fileURLToPath } from 'node:url';\n// import { injectDmnoGlobals } from 'dmno/injector-standalone';\n// import { resolve } from 'import-meta-resolve';\nimport type { NextConfig } from 'next';\n// import { getBuildTimeReplacements, patchServerResponseToPreventClientLeaks, scanForLeaks } from 'varlock';\n\nimport { redactSensitiveConfig, scanForLeaks } from './runtime';\nimport { patchServerResponseToPreventClientLeaks } from './patch-server-response';\nimport { patchConsole } from './patch-console';\nimport path from 'node:path';\n\npatchConsole();\n\nconst IS_WORKER = !!process.env.NEXT_PRIVATE_WORKER;\nfunction debug(...args: Array<any>) {\n  if (!process.env.DEBUG_VARLOCK_NEXT_INTEGRATION) return;\n  console.log(\n    'plugin',\n    IS_WORKER ? '[worker] ' : '[server]',\n    '--',\n    ...args,\n  );\n}\ndebug('✨ LOADED @varlock/next-integration/plugin module!');\n\nconst ENABLE_LEAK_DETECTION = true;\n\n// const {\n//   staticReplacements, dynamicKeys, injectedDmnoEnv, serviceSettings,\n// } = injectDmnoGlobals();\n\ntype VarlockPluginOptions = {\n  // injectResolvedConfigAtBuildTime: boolean,\n};\n\n\n\nlet scannedStaticFiles = false;\nasync function scanStaticFiles(nextDirPath: string) {\n  scannedStaticFiles = true;\n  for await (const file of fs.promises.glob(nextDirPath + '/**/*.html')) {\n    const fileContents = await fs.promises.readFile(file, 'utf8');\n    scanForLeaks(fileContents, { method: 'nextjs scan static html files', file });\n  }\n}\n\n// this seems to not catch anything in next 15 - as it only covers manifest files\n// but it can't hurt to add it\nfunction patchFsWriteFileToScanForLeaks() {\n  // patch fs.promises.writeFile\n  const origWriteFileFn = fs.promises.writeFile;  \n  fs.promises.writeFile = async function dmnoPatchedWriteFile(...args) {\n    const [filePath, fileContents] = arguments;\n    // console.log('⚡️ patched fs.promises.writeFile', filePath);\n\n    if (filePath.endsWith('/.next/next-server.js.nft.json') && !scannedStaticFiles) {\n      const nextDirPath = (filePath as string).substring(0, filePath.lastIndexOf('/'));\n      await scanStaticFiles(nextDirPath);\n    }\n\n    // // naively enable/disable detection based on file extension... probably not the best logic but it might be enough?\n    // if (\n    //   filePath.endsWith('.html')\n    //   || filePath.endsWith('.rsc')\n    //   || filePath.endsWith('.body')\n    //   // we also need to scan .js files, but they are already built by webpack so we can't catch it here\n    // ) {\n    //   // TODO: better error details to help user _find_ the problem\n    //   scanForLeaks(fileContents, { method: 'nextjs fs.writeFile', file: filePath });\n    // }\n\n    // @ts-ignore\n    return origWriteFileFn.call(this, ...Array.from(arguments));\n  };\n\n  // // patch fs.promises.copyFile\n  // const origCopyFileFn = fs.promises.copyFile;  \n  // // @ts-ignore\n  // fs.promises.copyFile = function dmnoPatchedCopyFile(...args) {\n  //   const [srcPath, destPath] = arguments;\n  //   console.log('⚡️ patched fs.promises.copyFile', srcPath, destPath);\n  //   // @ts-ignore\n  //   return origCopyFileFn.call(this, ...Array.from(arguments));\n  // }\n\n  // for (const [fnName, origFn] of Object.entries(fs.promises)) {\n  //   (fs.promises as any)[fnName] = function (...args: any[]) {\n  //     console.log('⚡️ patched fs.promises -- ', fnName, args[0]);\n  //     // @ts-ignore\n  //     return origFn.call(this, ...Array.from(arguments));\n  //   }\n  // }\n  // for (const [fnName, origFn] of Object.entries(fs)) {\n  //   if (typeof origFn !== 'function') continue;\n  //   (fs as any)[fnName] = function (...args: any[]) {\n  //     console.log('⚡️ patched fs -- ', fnName, args[0]);\n  //     // @ts-ignore\n  //     return origFn.call(this, ...Array.from(arguments));\n  //   }\n  // }\n\n\n  // const origWriteFileFn = fs.writeFile;  \n  // // @ts-ignore\n  // fs.writeFile = function dmnoPatchedWriteFile(...args) {\n  //   const [filePath, fileContents] = arguments;\n  //   console.log('⚡️ patched fs.writeFile', filePath);\n  //   // @ts-ignore\n  //   return origWriteFileFn.call(this, ...Array.from(arguments));\n  // }\n\n\n  // const origWriteFileSyncFn = fs.writeFileSync;  \n  // // @ts-ignore\n  // fs.writeFileSync = function dmnoPatchedWriteFileSync(...args) {\n  //   const [filePath, fileContents] = arguments;\n  //   console.log('⚡️ patched fs.writeFileSync', filePath);\n  //   // @ts-ignore\n  //   return origWriteFileSyncFn.call(this, ...Array.from(arguments));\n  // }\n}\n\n\n\nexport type NextConfigFunction = (\n  phase: string,\n  defaults: { defaultConfig: NextConfig },\n) => NextConfig | PromiseLike<NextConfig>;\n\n\n\nconst WEBPACK_PLUGIN_NAME = 'VarlockNextWebpackPlugin';\n\n// function getCjsModuleSource(moduleName: string) {\n//   const modulePath = fileURLToPath(resolve(moduleName, import.meta.url)).replace('.js', '.cjs');\n//   const moduleSrc = fs.readFileSync(modulePath, 'utf8');\n//   return moduleSrc;\n// }\n\n// function getCjsModuleSource(moduleName: string) {\n  \n//   require.resolve(moduleName);\n\n//   const modulePath = fileURLToPath(resolve(moduleName, import.meta.url)).replace('.js', '.cjs');\n//   const moduleSrc = fs.readFileSync(modulePath, 'utf8');\n//   return moduleSrc;\n// }\n\n// we make this a function because we'll likely end up adding some options\nexport function varlockNextConfigPlugin(pluginOptions?: VarlockPluginOptions) {\n  // nextjs doesnt have a proper plugin system, so we write a function which takes in a config object and returns an augmented one\n  return (nextConfig: any | NextConfig | NextConfigFunction): NextConfigFunction => {\n    return async (phase: string, defaults: { defaultConfig: NextConfig }) => {\n      let resolvedNextConfig: NextConfig;\n      if (typeof nextConfig === 'function') {\n        const nextConfigFnResult = nextConfig(phase, defaults);\n        resolvedNextConfig = await nextConfigFnResult;\n      } else {\n        resolvedNextConfig = nextConfig;\n      }\n\n      return {\n        ...resolvedNextConfig,\n        webpack(webpackConfig, options) {\n          const { isServer, dev, nextRuntime } = options;\n\n\n          if (ENABLE_LEAK_DETECTION) {\n            // patches fs.writeFile to scan files output by next itself for leaks\n            // (does not include files output during webpack build)\n            patchFsWriteFileToScanForLeaks();\n\n            // have to wait until here when we know if this is dev mode or not\n            patchServerResponseToPreventClientLeaks({\n              ignoreUrlPatterns: [/^\\/__nextjs_source-map\\?.*/],\n              scrub: dev,\n            });\n          }\n\n          // webpack itself  is passed in so we dont have to import it...\n          const webpack = options.webpack;\n\n          // apply existing user customizations if there are any\n          if (resolvedNextConfig.webpack) {\n            webpackConfig = resolvedNextConfig.webpack(webpackConfig, options);\n          }\n\n\n          // Set up build-time replacements / rewrites (using webpack.DefinePlugin)\n          const staticReplacements = {} as Record<string, string>; // getBuildTimeReplacements({\n          const varlockEnv = JSON.parse(process.env.__VARLOCK_ENV || '{}') as Record<string, { value: string, isSensitive: boolean }>;\n          for (const [key, value] of Object.entries(varlockEnv)) {\n            if (!value.isSensitive) {\n              staticReplacements[`ENV.${key}`] = JSON.stringify(value.value);\n            }\n          }\n\n          debug('adding static replacements!', staticReplacements);\n          webpackConfig.plugins.push(new webpack.DefinePlugin(staticReplacements));\n\n          webpackConfig.plugins.push({\n            apply(compiler: any) {\n              compiler.hooks.assetEmitted.tap(WEBPACK_PLUGIN_NAME, (file: any, assetDetails: any) => {\n                const { content, targetPath } = assetDetails;\n                debug('emit file: ', targetPath);\n\n                if (\n                  targetPath.includes('/.next/static/chunks/')\n                  || targetPath.endsWith('.html')\n                  || targetPath.endsWith('.body')\n                  || targetPath.endsWith('.rsc')\n                ) {\n                  // NOTE - in dev mode the request hangs on the error, but the console error should help\n                  // and during a build, it will actually fail the build\n                  try {\n                    scanForLeaks(content, {\n                      method: '@varlock/nextjs-integration/plugin - assetEmitted hook',\n                      file: targetPath,\n                    });\n                  } catch (err) {\n                    if (dev) {\n                      // overwrite file with redacted version\n                      fs.writeFileSync(targetPath, redactSensitiveConfig(content.toString()));\n                    } else {\n                      throw err;\n                    }\n                  }\n                }\n              });\n            },\n          });\n\n\n\n\n          // we need to inject the dmno globals injector and call it\n          // and in vercel/netlify etc where we can't run via `dmno run` we need to inject the resolved config into the build\n          // not sure if this is the best way, but injecting into the `webpack-runtime.js` file seems to run everywhere\n\n          // updates the webpack source to inject dmno global logic and call it\n          // we run this on the runtimes for serverless and edge\n          function injectVarlockInitIntoWebpackRuntime(edgeRuntime = false) {\n            return function (origSource: any) {\n              const origSourceStr = origSource.source();\n\n              // we will inline the injector code, but need a different version if we are running in the edge runtime\n              // const injectorSrc = getCjsModuleSource(`dmno/injector-standalone${edgeRuntime ? '/edge' : ''}`);\n              const injectorPath = path.resolve(__dirname, './injector.js');\n              const injectorSrc = fs.readFileSync(injectorPath, 'utf8');\n              \n\n              const updatedSourceStr = [\n                // we use `headers()` to force next into dynamic rendering mode, but on the edge runtime it's always dynamic\n                // (see below for where headers is used)\n                // !edgeRuntime ? 'const { headers } = require(\"next/headers\");' : '',\n\n                // // code built for edge runtime does not have `module.exports` or `exports` but we are inlining some already built common-js code\n                // // so we just create them. It's not needed since it is inlined and we call the function right away\n                // edgeRuntime ? 'const module = { exports: {} }; const exports = {}' : '',\n\n                // inline the dmno injector code and then call it\n                injectorSrc,\n\n                // 'injectDmnoGlobals({',\n                // injectResolvedConfigAtBuildTime ? `injectedConfig: ${JSON.stringify(injectedDmnoEnv)},` : '',\n\n                // // attempts to force the route into dynamic rendering mode so it wont put our our dynamic value into a pre-rendered page\n                // // however we have to wrap in try/catch because you can only call headers() within certain parts of the page... so it's not 100% foolproof\n                // !edgeRuntime ? `\n                //   onItemAccess: async (item) => {\n                //     if (item.dynamic) {\n                //       try { headers(); }\n                //       catch (err) {}\n                //     }\n                //   },` : '',\n                // '});',\n\n                origSourceStr,\n              ].join('\\n');\n\n              return new webpack.sources.RawSource(updatedSourceStr);\n            };\n          }\n\n          webpackConfig.plugins.push({\n            apply(compiler: any) {\n              compiler.hooks.thisCompilation.tap(WEBPACK_PLUGIN_NAME, (compilation: any) => {\n                compilation.hooks.processAssets.tap(\n                  {\n                    name: WEBPACK_PLUGIN_NAME,\n                    stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS,\n                  },\n                  () => {\n                    // not sure why, but these paths are different in build vs dev\n                    if (compilation.getAsset('webpack-runtime.js')) {\n                      compilation.updateAsset('webpack-runtime.js', injectVarlockInitIntoWebpackRuntime());\n                    }\n                    if (compilation.getAsset('../webpack-runtime.js')) {\n                      compilation.updateAsset('../webpack-runtime.js', injectVarlockInitIntoWebpackRuntime());\n                    }\n                    if (compilation.getAsset('webpack-api-runtime.js')) {\n                      compilation.updateAsset('webpack-api-runtime.js', injectVarlockInitIntoWebpackRuntime());\n                    }\n                    if (compilation.getAsset('../webpack-api-runtime.js')) {\n                      compilation.updateAsset('../webpack-api-runtime.js', injectVarlockInitIntoWebpackRuntime());\n                    }\n\n                    if (compilation.getAsset('edge-runtime-webpack.js')) {\n                      compilation.updateAsset('edge-runtime-webpack.js', injectVarlockInitIntoWebpackRuntime(true));\n                    }\n                  },\n                );\n              });\n            }\n\n          });\n\n          return webpackConfig; // must return the modified config\n        },\n      };\n    };\n  };\n}\n"]}