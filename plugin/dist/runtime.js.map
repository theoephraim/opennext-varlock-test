{"version":3,"sources":["../src/runtime.ts"],"names":[],"mappings":"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","file":"runtime.js","sourcesContent":["const UNMASK_STR = 'üëÅ';\n\nexport type RedactMode = 'show_first_2' | 'show_last_2' | 'show_first_last';\n\n/**\n * utility to mask/redact a string, for example transforming \"hello\" into \"he‚ñí‚ñí‚ñí\"\n * this function just redacts _any_ string passed in\n *\n * To redact sensitive parts of a larger object/string, use redactSensitiveConfig\n * */\nexport function redactString(valStr: string | undefined, mode?: RedactMode, hideLength = true) {\n  if (!valStr) return valStr;\n\n  const hiddenLength = hideLength ? 5 : valStr.length - 2;\n  const hiddenStr = '‚ñí'.repeat(hiddenLength);\n\n  if (mode === 'show_last_2') {\n    return `${hiddenStr}${valStr.substring(valStr.length - 2, valStr.length)}`;\n  } else if (mode === 'show_first_last') {\n    return `${valStr.substring(0, 1)}${hiddenStr}${valStr.substring(valStr.length - 1, valStr.length)}`;\n  } else { // 'show_first_2' - also default\n    return `${valStr.substring(0, 2)}${hiddenStr}`;\n  }\n}\n\n\n\n/** key value lookup of sensitive values to their redacted version */\nlet sensitiveSecretsMap: Record<string, { key: string, redacted: string }> = {};\n\ntype ReplaceFn = (match: string, pre: string, val: string, post: string) => string;\nlet redactorFindReplace: undefined | { find: RegExp, replace: ReplaceFn };\n\nexport function resetRedactionMap(graph: { config: Record<string, { isSensitive: boolean, value: string }> }) {\n  // reset map of { [sensitive] => redacted }\n  sensitiveSecretsMap = {};\n  for (const itemKey in graph.config) {\n    const item = graph.config[itemKey];\n    if (item.isSensitive && item.value && isString(item.value)) {\n      // TODO: we want to respect masking settings from the schema (once added)\n      const redacted = redactString(item.value);\n      if (redacted) sensitiveSecretsMap[item.value] = { key: itemKey, redacted };\n    }\n  }\n\n  // reset find/replace regex+fn used for redacting secrets in strings\n  const findRegex = new RegExp(\n    [\n      `(${UNMASK_STR} )?`,\n      '(',\n      Object.keys(sensitiveSecretsMap)\n        // Escape special characters\n        .map((s) => s.replace(/[()[\\]{}*+?^$|#.,/\\\\\\s-]/g, '\\\\$&'))\n        // Sort for maximal munch\n        .sort((a, b) => b.length - a.length)\n        .join('|'),\n      ')',\n      `( ${UNMASK_STR})?`,\n    ].join(''),\n    'g',\n  );\n\n  const replaceFn: ReplaceFn = (match, pre, val, post) => {\n    // the pre and post matches only will be populated if they were present\n    // and they are used to unmask the secret - so we do not want to replace in this case\n    if (pre && post) return match;\n    return sensitiveSecretsMap[val].redacted;\n  };\n  redactorFindReplace = { find: findRegex, replace: replaceFn };\n}\n\n\n// While the module itself acts as a singleton to hold the current map of redacted values\n// we expose only the below const to end users\n\n\n/**\n * Redacts senstive config values from any string/array/object/etc\n *\n * NOTE - must be used only after varlock has loaded config\n * */\nexport function redactSensitiveConfig(o: any): any {\n  if (!redactorFindReplace) return o;\n  if (!o) return o;\n\n  // TODO: handle more cases?\n  // we can probably redact safely from a few other datatypes - like set,map,etc?\n  // objects are a bit tougher\n  if (Array.isArray(o)) {\n    return o.map(redactSensitiveConfig);\n  }\n  // try to redact if it's a plain object - not necessarily great for perf...\n  if (o && typeof (o) === 'object' && Object.getPrototypeOf(o) === Object.prototype) {\n    try {\n      return JSON.parse(redactSensitiveConfig(JSON.stringify(o)));\n    } catch (err) {\n      return o;\n    }\n  }\n\n  const type = typeof o;\n  if (type === 'string' || (type === 'object' && Object.prototype.toString.call(o) === '[object String]')) {\n    return (o as string).replaceAll(redactorFindReplace.find, redactorFindReplace.replace);\n  }\n\n  return o;\n}\n\n/**\n * utility to unmask a secret/sensitive value when logging to the console\n * currently this only works on a single secret, not objects or aggregated strings\n * */\nexport function revealSensitiveConfig(secretStr: string) {\n  // if redaction not enabled, we just return the secret itself\n  if (!(globalThis as any)._varlockOrigWriteToConsoleFn) return secretStr;\n  // otherwise we add some wrapper characters which will be removed by the patched console behaviour\n  return `${UNMASK_STR} ${secretStr} ${UNMASK_STR}`;\n}\n\n\n\n// this does not cover all cases, but serves our needs so far for Next.js\nfunction isString(s: any) {\n  return Object.prototype.toString.call(s) === '[object String]';\n}\n\n// reusable leak scanning helper function, used by various integrations\nexport function scanForLeaks(\n  toScan: string | Response | ReadableStream,\n  // optional additional information about what is being scanned to be used in error messages\n  meta?: {\n    method?: string,\n    file?: string,\n  },\n) {\n  function scanStrForLeaks(strToScan: string) {\n    // console.log('[varlock leak scanner] ', strToScan.substr(0, 100));\n\n    // TODO: probably should use a single regex\n    for (const sensitiveValue in sensitiveSecretsMap) {\n      if (strToScan.includes(sensitiveValue)) {\n        const itemKey = sensitiveSecretsMap[sensitiveValue].key;\n\n        // error stack can gets awkwardly buried since we're so deep in the internals\n        // so we'll write a nicer error message to help the user debug\n        console.error([\n          '',\n          `üö® ${'DETECTED LEAKED SENSITIVE CONFIG'} üö®`,\n          `> Config item key: ${itemKey}`,\n          ...meta?.method ? [`> Scan method: ${meta.method}`] : [],\n          ...meta?.file ? [`> File: ${meta.file}`] : [],\n          '',\n        ].join('\\n'));\n\n        throw new Error(`üö® DETECTED LEAKED SENSITIVE CONFIG - ${itemKey}`);\n      }\n    }\n  }\n\n  // scan a string\n  if (isString(toScan)) {\n    scanStrForLeaks(toScan as string);\n    return toScan;\n  } else if (toScan instanceof Buffer) {\n    scanStrForLeaks(toScan.toString());\n    return toScan;\n  // scan a ReadableStream by piping it through a scanner\n  } else if (toScan instanceof ReadableStream) {\n    if (toScan.locked) {\n      // console.log('> stream already locked');\n      return toScan;\n    } else {\n      // console.log('> stream will be scanned!');\n    }\n    const chunkDecoder = new TextDecoder();\n    return toScan.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          const chunkStr = chunkDecoder.decode(chunk);\n          scanStrForLeaks(chunkStr);\n          controller.enqueue(chunk);\n        },\n      }),\n    );\n  }\n  // other things may be passed in like Buffer... but we'll ignore for now\n  return toScan;\n}\n\n// -----------\n\n\n\n\n// --------------\n\nlet initializedEnv = false;\nconst envValues = {} as Record<string, any>;\nconsole.log('LOADED ENV RUNTIME - initialized?', initializedEnv);\n\n\nexport function initVarlockEnv() {\n  console.log('‚ö°Ô∏è INIT VARLOCK ENV!');\n  try {\n    const serializedEnvData: Record<string, { value: string, isSensitive: boolean }> = JSON.parse(process.env.__VARLOCK_ENV || '{}');\n    resetRedactionMap({ config: serializedEnvData });\n    for (const [key, value] of Object.entries(serializedEnvData)) {\n      envValues[key] = (value as any).value;\n    }\n  } catch (err) {\n    console.error('failed to load varlock env', err, process.env.__VARLOCK_ENV);\n  }\n  initializedEnv = true;\n}\n\nif (process.env.__VARLOCK_ENV && !initializedEnv) initVarlockEnv();\n\nconst EnvProxy = new Proxy({} as Record<string, any>, {\n  get(target, prop) {\n    if (typeof prop !== 'string') throw new Error('prop keys cannot be symbols');\n    return envValues[prop];\n  },\n});\n\nexport const ENV = EnvProxy;\n"]}