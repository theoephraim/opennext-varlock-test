{"version":3,"sources":["../src/runtime.ts","../src/patch-console.ts","../src/patch-server-response.ts","../src/patch-response.ts","../src/injector.ts"],"names":["ServerResponse","zlib"],"mappings":"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","file":"injector.js","sourcesContent":["const UNMASK_STR = 'üëÅ';\n\nexport type RedactMode = 'show_first_2' | 'show_last_2' | 'show_first_last';\n\n/**\n * utility to mask/redact a string, for example transforming \"hello\" into \"he‚ñí‚ñí‚ñí\"\n * this function just redacts _any_ string passed in\n *\n * To redact sensitive parts of a larger object/string, use redactSensitiveConfig\n * */\nexport function redactString(valStr: string | undefined, mode?: RedactMode, hideLength = true) {\n  if (!valStr) return valStr;\n\n  const hiddenLength = hideLength ? 5 : valStr.length - 2;\n  const hiddenStr = '‚ñí'.repeat(hiddenLength);\n\n  if (mode === 'show_last_2') {\n    return `${hiddenStr}${valStr.substring(valStr.length - 2, valStr.length)}`;\n  } else if (mode === 'show_first_last') {\n    return `${valStr.substring(0, 1)}${hiddenStr}${valStr.substring(valStr.length - 1, valStr.length)}`;\n  } else { // 'show_first_2' - also default\n    return `${valStr.substring(0, 2)}${hiddenStr}`;\n  }\n}\n\n\n\n/** key value lookup of sensitive values to their redacted version */\nlet sensitiveSecretsMap: Record<string, { key: string, redacted: string }> = {};\n\ntype ReplaceFn = (match: string, pre: string, val: string, post: string) => string;\nlet redactorFindReplace: undefined | { find: RegExp, replace: ReplaceFn };\n\nexport function resetRedactionMap(graph: { config: Record<string, { isSensitive: boolean, value: string }> }) {\n  // reset map of { [sensitive] => redacted }\n  sensitiveSecretsMap = {};\n  for (const itemKey in graph.config) {\n    const item = graph.config[itemKey];\n    if (item.isSensitive && item.value && isString(item.value)) {\n      // TODO: we want to respect masking settings from the schema (once added)\n      const redacted = redactString(item.value);\n      if (redacted) sensitiveSecretsMap[item.value] = { key: itemKey, redacted };\n    }\n  }\n\n  // reset find/replace regex+fn used for redacting secrets in strings\n  const findRegex = new RegExp(\n    [\n      `(${UNMASK_STR} )?`,\n      '(',\n      Object.keys(sensitiveSecretsMap)\n        // Escape special characters\n        .map((s) => s.replace(/[()[\\]{}*+?^$|#.,/\\\\\\s-]/g, '\\\\$&'))\n        // Sort for maximal munch\n        .sort((a, b) => b.length - a.length)\n        .join('|'),\n      ')',\n      `( ${UNMASK_STR})?`,\n    ].join(''),\n    'g',\n  );\n\n  const replaceFn: ReplaceFn = (match, pre, val, post) => {\n    // the pre and post matches only will be populated if they were present\n    // and they are used to unmask the secret - so we do not want to replace in this case\n    if (pre && post) return match;\n    return sensitiveSecretsMap[val].redacted;\n  };\n  redactorFindReplace = { find: findRegex, replace: replaceFn };\n}\n\n\n// While the module itself acts as a singleton to hold the current map of redacted values\n// we expose only the below const to end users\n\n\n/**\n * Redacts senstive config values from any string/array/object/etc\n *\n * NOTE - must be used only after varlock has loaded config\n * */\nexport function redactSensitiveConfig(o: any): any {\n  if (!redactorFindReplace) return o;\n  if (!o) return o;\n\n  // TODO: handle more cases?\n  // we can probably redact safely from a few other datatypes - like set,map,etc?\n  // objects are a bit tougher\n  if (Array.isArray(o)) {\n    return o.map(redactSensitiveConfig);\n  }\n  // try to redact if it's a plain object - not necessarily great for perf...\n  if (o && typeof (o) === 'object' && Object.getPrototypeOf(o) === Object.prototype) {\n    try {\n      return JSON.parse(redactSensitiveConfig(JSON.stringify(o)));\n    } catch (err) {\n      return o;\n    }\n  }\n\n  const type = typeof o;\n  if (type === 'string' || (type === 'object' && Object.prototype.toString.call(o) === '[object String]')) {\n    return (o as string).replaceAll(redactorFindReplace.find, redactorFindReplace.replace);\n  }\n\n  return o;\n}\n\n/**\n * utility to unmask a secret/sensitive value when logging to the console\n * currently this only works on a single secret, not objects or aggregated strings\n * */\nexport function revealSensitiveConfig(secretStr: string) {\n  // if redaction not enabled, we just return the secret itself\n  if (!(globalThis as any)._varlockOrigWriteToConsoleFn) return secretStr;\n  // otherwise we add some wrapper characters which will be removed by the patched console behaviour\n  return `${UNMASK_STR} ${secretStr} ${UNMASK_STR}`;\n}\n\n\n\n// this does not cover all cases, but serves our needs so far for Next.js\nfunction isString(s: any) {\n  return Object.prototype.toString.call(s) === '[object String]';\n}\n\n// reusable leak scanning helper function, used by various integrations\nexport function scanForLeaks(\n  toScan: string | Response | ReadableStream,\n  // optional additional information about what is being scanned to be used in error messages\n  meta?: {\n    method?: string,\n    file?: string,\n  },\n) {\n  function scanStrForLeaks(strToScan: string) {\n    // console.log('[varlock leak scanner] ', strToScan.substr(0, 100));\n\n    // TODO: probably should use a single regex\n    for (const sensitiveValue in sensitiveSecretsMap) {\n      if (strToScan.includes(sensitiveValue)) {\n        const itemKey = sensitiveSecretsMap[sensitiveValue].key;\n\n        // error stack can gets awkwardly buried since we're so deep in the internals\n        // so we'll write a nicer error message to help the user debug\n        console.error([\n          '',\n          `üö® ${'DETECTED LEAKED SENSITIVE CONFIG'} üö®`,\n          `> Config item key: ${itemKey}`,\n          ...meta?.method ? [`> Scan method: ${meta.method}`] : [],\n          ...meta?.file ? [`> File: ${meta.file}`] : [],\n          '',\n        ].join('\\n'));\n\n        throw new Error(`üö® DETECTED LEAKED SENSITIVE CONFIG - ${itemKey}`);\n      }\n    }\n  }\n\n  // scan a string\n  if (isString(toScan)) {\n    scanStrForLeaks(toScan as string);\n    return toScan;\n  } else if (toScan instanceof Buffer) {\n    scanStrForLeaks(toScan.toString());\n    return toScan;\n  // scan a ReadableStream by piping it through a scanner\n  } else if (toScan instanceof ReadableStream) {\n    if (toScan.locked) {\n      // console.log('> stream already locked');\n      return toScan;\n    } else {\n      // console.log('> stream will be scanned!');\n    }\n    const chunkDecoder = new TextDecoder();\n    return toScan.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          const chunkStr = chunkDecoder.decode(chunk);\n          scanStrForLeaks(chunkStr);\n          controller.enqueue(chunk);\n        },\n      }),\n    );\n  }\n  // other things may be passed in like Buffer... but we'll ignore for now\n  return toScan;\n}\n\n// -----------\n\n\n\n\n// --------------\n\nlet initializedEnv = false;\nconst envValues = {} as Record<string, any>;\nconsole.log('LOADED ENV RUNTIME - initialized?', initializedEnv);\n\n\nexport function initVarlockEnv() {\n  console.log('‚ö°Ô∏è INIT VARLOCK ENV!');\n  try {\n    const serializedEnvData: Record<string, { value: string, isSensitive: boolean }> = JSON.parse(process.env.__VARLOCK_ENV || '{}');\n    resetRedactionMap({ config: serializedEnvData });\n    for (const [key, value] of Object.entries(serializedEnvData)) {\n      envValues[key] = (value as any).value;\n    }\n  } catch (err) {\n    console.error('failed to load varlock env', err, process.env.__VARLOCK_ENV);\n  }\n  initializedEnv = true;\n}\n\nif (process.env.__VARLOCK_ENV && !initializedEnv) initVarlockEnv();\n\nconst EnvProxy = new Proxy({} as Record<string, any>, {\n  get(target, prop) {\n    if (typeof prop !== 'string') throw new Error('prop keys cannot be symbols');\n    return envValues[prop];\n  },\n});\n\nexport const ENV = EnvProxy;\n","import { redactSensitiveConfig } from \"./runtime\";\n\n\n/**\n * patches global console methods to redact sensitive config\n *\n * NOTE - this may not be 100% foolproof depending on the platform\n * */\nexport function patchConsole() {\n  console.log('‚ö°Ô∏è PATCHING CONSOLE!');\n  /* eslint-disable no-console, prefer-rest-params */\n  // if (!redactorFindReplace) return;\n\n  // our method of patching involves replacing an internal node method which may not be called if console.log itself has also been patched\n  // for example AWS lambdas patches this to write the logs to a file which then is pushed to the rest of their system\n\n  // so first we'll just patch the internal method do deal with normal stdout/stderr logs -------------------------------------\n\n  // we need the internal symbol name to access the internal method\n  const kWriteToConsoleSymbol = Object.getOwnPropertySymbols(globalThis.console).find((s) => s.description === 'kWriteToConsole');\n\n  // @ts-ignore\n  (globalThis as any)._varlockOrigWriteToConsoleFn ||= globalThis.console[kWriteToConsoleSymbol];\n  // @ts-ignore\n  globalThis.console[kWriteToConsoleSymbol] = function () {\n    (globalThis as any)._varlockOrigWriteToConsoleFn.apply(this, [\n      arguments[0],\n      redactSensitiveConfig(arguments[1]),\n      arguments[2],\n    ]);\n  };\n\n  // and now we'll wrap console.log (and the other methods) if it looks like they have been patched already ------------------\n  // NOTE - this will not fully redact from everything since we can't safely reach deep into objects\n  // ideally we would only turn this when the above method does not work, but it's not trivial to detect when it that is the case\n  // so we'll turn it on all the time for now...\n  if (\n    // !console.log.toString().includes('[native code]') &&\n    !(console.log as any)._varlockPatchedFn\n  ) {\n    for (const logMethodName of ['trace', 'debug', 'info', 'log', 'info', 'warn', 'error']) {\n      // @ts-ignore\n      const originalLogMethod = globalThis.console[logMethodName];\n\n      const patchedFn = function () {\n        // @ts-ignore\n        originalLogMethod.apply(this, Array.from(arguments).map(redactSensitiveConfig));\n      };\n      patchedFn._varlockPatchedFn = true;\n\n      // @ts-ignore\n      globalThis.console[logMethodName] = patchedFn;\n    }\n  }\n}\n\n/**\n * restore's original global console methods to stop redacting secrets\n *\n * (only needed during local development when switching settings on/off in a process that does not reload)\n * */\nexport function unpatchConsole() {\n  // we'll only care about the normal case where console.log has NOT been patched by something else... (see above)\n  if (!(globalThis as any)._varlockOrigWriteToConsoleFn) return;\n\n  const kWriteToConsoleSymbol = Object.getOwnPropertySymbols(globalThis.console).find((s) => s.description === 'kWriteToConsole');\n  // @ts-ignore\n  globalThis.console[kWriteToConsoleSymbol] = (globalThis as any)._varlockOrigWriteToConsoleFn;\n  delete (globalThis as any)._varlockOrigWriteToConsoleFn;\n}\n\n// ---\n\n// patchConsole();","/*\n  This patches the global ServerResponse object to scan for secret leaks - currently used for next.js and remix\n*/\n\nimport zlib from 'node:zlib';\nimport { ServerResponse } from 'node:http';\nimport { redactSensitiveConfig, scanForLeaks } from './runtime';\n\n// NOTE - previously was using a symbol but got weird because of multiple builds and contexts...\nconst patchedKey = '_patchedByVarlock';\nexport function patchServerResponseToPreventClientLeaks(opts?: {\n  ignoreUrlPatterns?: Array<RegExp>,\n  scrub?: boolean,\n}) {\n  console.log('‚ö°Ô∏è patching ServerResponse');\n  if (Object.getOwnPropertyDescriptor(ServerResponse.prototype, patchedKey)) {\n    console.log('> already patched');\n    return;\n  }\n  \n\n  Object.defineProperty(ServerResponse.prototype, patchedKey, { value: true });\n\n  const serverResponseWrite = ServerResponse.prototype.write;\n\n  // @ts-ignore\n  ServerResponse.prototype.write = function varlockPatchedServerResponseWrite(...args) {\n    console.log('‚ö°Ô∏è patched ServerResponse.write');\n    // TODO: do we want to filter out some requests here? maybe based on the file type?\n\n    const rawChunk = args[0];\n\n    // for now, we only scan rendered html... may need to change this though for server components?\n    // so we bail if it looks like this response does not contain html\n    const contentType = this.getHeader('content-type')?.toString() || '';\n    // console.log('patched ServerResponse.write', contentType);\n    let runScan = (\n      contentType.startsWith('text/')\n      || contentType.startsWith('application/json')\n      // || contentType.startsWith('application/javascript')\n    );\n\n    const reqUrl = (this as any).req.url;\n    // console.log('> scan ServerResponse.write', contentType, reqUrl);\n    if (runScan && reqUrl && opts?.ignoreUrlPatterns?.some((pattern) => pattern.test(reqUrl))) {\n      runScan = false;\n    }\n\n    // we want to run the scanner on text/html and text/x-component (server actions)\n    // TODO: anything else?\n    if (!runScan) {\n      // @ts-ignore\n      return serverResponseWrite.apply(this, args);\n    }\n\n    // have to deal with compressed data, which is awkward but possible\n    const compressionType = this.getHeader('Content-Encoding');\n    let chunkStr;\n    let chunkType: 'string' | 'encoded' | 'gzip' | null = null;\n    if (typeof rawChunk === 'string') {\n      chunkType = 'string';\n      chunkStr = rawChunk;\n    } else if (!compressionType) {\n      chunkType = 'encoded';\n      const decoder = new TextDecoder();\n      chunkStr = decoder.decode(rawChunk);\n    } else if (compressionType === 'gzip') {\n      chunkType = 'gzip';\n      // first chunk of data contains only compression headers\n      if (!(this as any)._zlibChunks) {\n        // (this as any)._zlibHeadersChunk = rawChunk;\n        (this as any)._zlibChunks = [rawChunk];\n      } else {\n        // TODO: figure out how we can unzip one chunk at a time instead of storing everything\n        (this as any)._zlibChunks?.push(rawChunk);\n        try {\n          const unzippedChunk = zlib.unzipSync(Buffer.concat((this as any)._zlibChunks || []), {\n            flush: zlib.constants.Z_SYNC_FLUSH,\n            finishFlush: zlib.constants.Z_SYNC_FLUSH,\n          });\n          const fullUnzippedData = unzippedChunk.toString('utf-8');\n          chunkStr = fullUnzippedData.substring((this as any)._lastChunkEndIndex || 0);\n          (this as any)._lastChunkEndIndex = fullUnzippedData.length;\n        } catch (err) {\n          // console.log('error unzipping chunk', err);\n        }\n      }\n    }\n    // TODO: we may want to support other compression schemes? but currently only used in nextjs which is using gzip\n    if (chunkStr) {\n      // console.log('scanning!', chunkStr.substring(0, 1000));\n\n      // eslint-disable-next-line no-useless-catch\n      try {\n        scanForLeaks(chunkStr, { method: 'patched ServerResponse.write', file: (this as any).req.url });\n      } catch (err) {\n        // console.log('found secret in chunk', chunkType, chunkStr);\n        // console.log(this)\n        if (opts?.scrub) {\n          chunkStr = redactSensitiveConfig(chunkStr);\n          if (chunkType === 'string') {\n            args[0] = chunkStr;\n          } else if (chunkType === 'encoded') {\n            const encoder = new TextEncoder();\n            args[0] = encoder.encode(chunkStr);\n          } else if (chunkType === 'gzip') {\n            // currently unable to scrub gzip chunks\n            // this works sometimes, but othertimes causes decoding error\n            // we'll need to pass through chunks from a new gzip stream, because we don't have access to the underlying one\n            // args[0] = zlib.gzipSync(chunkStr, {\n            //   flush: zlib.constants.Z_SYNC_FLUSH,\n            //   finishFlush: zlib.constants.Z_SYNC_FLUSH,\n            // });\n          } else {\n            throw new Error('unable to scrub - unknown chunk type ' + chunkType);\n          }\n        } else {\n          throw err;  \n        }\n      }\n    }\n\n    // @ts-ignore\n    return serverResponseWrite.apply(this, args);\n  };\n\n\n  // calling `res.json()` in the api routes on pages router calls `res.end` without called `res.write`\n  const serverResponseEnd = ServerResponse.prototype.end;\n  // @ts-ignore\n  ServerResponse.prototype.end = function patchedServerResponseEnd(...args) {\n    // console.log('‚ö°Ô∏è patched ServerResponse.end');\n    const endChunk = args[0];\n    // console.log('patched ServerResponse.end', endChunk);\n    // this just needs to work (so far) for nextjs sending json bodies, so does not need to handle all cases...\n    if (endChunk && typeof endChunk === 'string') {\n      // TODO: currently this throws the error and then things just hang... do we want to try to return an error type response instead?\n      scanForLeaks(endChunk, { method: 'patched ServerResponse.end' });\n    }\n    // @ts-ignore\n    return serverResponseEnd.apply(this, args);\n  };\n}\n\n// ---\n// patchServerResponseToPreventClientLeaks();\n","import { scanForLeaks } from \"./runtime\";\n\nexport function patchResponseToPreventClientLeaks() {\n  if (!(globalThis.Response as any)._patchedByVarlock) {\n    console.log('‚ö°Ô∏èpatching Response');\n    const _UnpatchedResponse = globalThis.Response;\n    globalThis.Response = class VarlockPatchedResponse extends _UnpatchedResponse {\n      static _patchedByVarlock = true;\n      constructor(body: any, init: any) {\n        // console.log('‚ö°Ô∏è patched Response constructor');\n        super(scanForLeaks(body, { method: 'patched Response constructor' }) as any, init);\n      }\n      static json(data: any, init: any) {\n        // console.log('patched Response.json');\n        scanForLeaks(JSON.stringify(data), { method: 'patched Response.json' });\n        const r = _UnpatchedResponse.json(data, init);\n        Object.setPrototypeOf(r, Response.prototype);\n        return r;\n      }\n    };\n  }\n}","import { patchConsole } from './patch-console';\nimport { patchServerResponseToPreventClientLeaks } from './patch-server-response';\nimport { patchResponseToPreventClientLeaks } from './patch-response';\n\npatchConsole();\npatchServerResponseToPreventClientLeaks();\npatchResponseToPreventClientLeaks();\n"]}